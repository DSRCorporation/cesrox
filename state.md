### Cesride
* PRs need to be merged 
  * `Exposed methods and fields needed for parside implementation` - https://github.com/WebOfTrust/cesride/pull/95
    * Issues / Blockers ?
  * Drop mutable references and stripping - https://github.com/WebOfTrust/cesride/pull/102
* FFI: No
  * Draft: https://github.com/WebOfTrust/cesride/pull/82
  * Uniffi can be added by pulling from https://github.com/DSRCorporation/cesrox/tree/ffi-library
    * Bad:
      * requires struct fields to be public
      * we have to use `dictionaries` and write additional wrapper object to make it more language friendly.


### Parside

There are two PRs opened for a while.

* `Initial parser implementation returning generic enum instead of groups`
    * State: `broken`
      * Reasons
          * We cannot return vector of `traits` (`Vec<Matter>` or `Vec<Indexer>`) defining static methods (`new`).
          * We need to know primitive kinds in order to parse the whole properly:
              * It is not enough to know only the fact that a group consists of 4 primitives.
              * Cesride (Keripy) logical primitives are not matched 1-1 to CESR data primitives. The same bytes can be parsed to a number of cesride primitives. For instance `Blake3_256` data encoded with `E` could refer to `Diger`, `Prefixer` or `Saider` as well as just be a Matter primitive.
* `Initial parser implementation including definitions for Groups`
    * State: `work`
        * Points to the branch (wait merges of PRâ€™s mentioned above)
    * How to support different tables? 
    * Do we need an ability to `inject` them? or we can define all possible inside of parside? 
        * Injection: Pass callback to parse groups by code
            * Parside will be very very thin - useless library.   
            * Most of the code will be inside of callbacks.
        * AFAIR: Stream bytes includes information about the version of the table.
            * Parside can known and define all possible versions
            * Parside handle bytes depending on the version
* FFI: No
    * Uniffi can be added by pulling from https://github.com/DSRCorporation/cesrox/tree/ffi-library
    * Jason stated that we can import UDL from other crate??

### CESROX
Rust library representing a combination of `cesride` and `parside` libraries: https://github.com/DSRCorporation/cesrox/tree/ffi-library

* Do we need to use Parside without Cesride and vice versa?

* From the  Rust side, it just uses  `cesride` and `parside` libraries. Exposes their public methods, and provides single binary.
* From FFI side, It contains
  * `uniffi `crate using which we can generate bindings for Kotlin, Python, Swift, Ruby
  * `wasm` crate  using which we can generate bindings for WebAssembly and NodeJS
  * wrappers:
    * Kotlin - language oriented wrapper on top of bindings generated by uniffi

* Single FFI library
    * Easier to distribute
    * Easier to consume




